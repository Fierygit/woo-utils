2019年10月15日 08:38:12

先限定好这是一个[一组生产者 + 一组消费者]的带ack的消息队列，不支持多组消费，已消费数据不再存储（因为已经带了ack机制了）

对于一个消息队列，一共有3个key来负责完成：

1. list：标准的redis list，存放消息的uuid，是未消费的uuid
2. doing_list：标准的redis list，存储正在消费过程中的消息uuid
3. msg_map: 标准的redis map，存储消息uuid到消息详情的数据
             消息详情包括：消息内容、消息发送时间、消息消费时间、消费ack超时默认时间、消息消费次数

原子操作：
1. 发送消息：入参是（消息主题，消息内容、消费ack超时时间），生成uuid，加入到msg_map中（设置好消息时间、ack超时时间等），再添加到list中，过程是阻塞的，两个操作完成了，即发送成功，返回消息uuid
2. 消费消息：入参是（消费主题，[ack超时时间(可选)]），使用https://redis.io/commands/brpoplpush 命令，将list列表中的任何一条消息拿出来，放到doing_list中，并返回该uuid。修改该uuid的消费时间和ack超时时间（特别说明: 这一步可能失败，应该由定时任务去修复）
3. 确认消息：从doing_list中删除该消息。删除msg_map中对应的uuid（特别说明：这一步可能失败，应该由定时任务去修复）

定时任务：
1. 清理doing_list中ack超时的消息：有一种情况
     1）消费时间没有设置的，等待30秒，如果还没有设置消费时间，则移到list中
     2）结合消费时间和ack超时时间判断为已消费超时的，清除消费时间，（这一步可能中断，由第1步修复），再移到list中
2. 清理过期的消息内容：对list和doing_list中没有的uuid，msg_map中删除掉，这个动作每天清理一次，清理时，确定uuid没有对应之后，应当等待30秒之后再进行删除，以免误删发送中的消息